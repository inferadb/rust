// This file is @generated by prost-build.
/// Evaluate permission request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EvaluateRequest {
    /// Subject (e.g., "user:alice")
    #[prost(string, tag = "1")]
    pub subject: ::prost::alloc::string::String,
    /// Resource (e.g., "doc:readme")
    #[prost(string, tag = "2")]
    pub resource: ::prost::alloc::string::String,
    /// Permission to evaluate (e.g., "reader")
    #[prost(string, tag = "3")]
    pub permission: ::prost::alloc::string::String,
    /// Optional context data
    #[prost(string, optional, tag = "4")]
    pub context: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional flag to include detailed evaluation trace for debugging
    #[prost(bool, optional, tag = "5")]
    pub trace: ::core::option::Option<bool>,
}
/// Evaluate response
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluateResponse {
    /// Decision (allow or deny)
    #[prost(enumeration = "Decision", tag = "1")]
    pub decision: i32,
    /// Index of the request this response corresponds to (for batch operations)
    #[prost(uint32, tag = "2")]
    pub index: u32,
    /// Error message if evaluation failed
    #[prost(string, optional, tag = "3")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional detailed evaluation trace (included when trace was set in request)
    #[prost(message, optional, tag = "4")]
    pub trace: ::core::option::Option<DecisionTrace>,
}
/// Decision trace for explainability
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecisionTrace {
    /// Final decision
    #[prost(enumeration = "Decision", tag = "1")]
    pub decision: i32,
    /// Root evaluation node
    #[prost(message, optional, tag = "2")]
    pub root: ::core::option::Option<EvaluationNode>,
    /// Duration in microseconds
    #[prost(uint64, tag = "3")]
    pub duration_micros: u64,
    /// Number of relationships read
    #[prost(uint64, tag = "4")]
    pub relationships_read: u64,
    /// Number of relations evaluated
    #[prost(uint64, tag = "5")]
    pub relations_evaluated: u64,
}
/// Evaluation node in the trace tree
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvaluationNode {
    /// Type of evaluation
    #[prost(message, optional, tag = "1")]
    pub node_type: ::core::option::Option<NodeType>,
    /// Result at this node
    #[prost(bool, tag = "2")]
    pub result: bool,
    /// Child nodes
    #[prost(message, repeated, tag = "3")]
    pub children: ::prost::alloc::vec::Vec<EvaluationNode>,
}
/// Node type in evaluation
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct NodeType {
    #[prost(oneof = "node_type::Type", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub r#type: ::core::option::Option<node_type::Type>,
}
/// Nested message and enum types in `NodeType`.
pub mod node_type {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        DirectCheck(super::DirectCheck),
        #[prost(message, tag = "2")]
        ComputedUserset(super::ComputedUserset),
        #[prost(message, tag = "3")]
        RelatedObjectUserset(super::RelatedObjectUserset),
        #[prost(message, tag = "4")]
        Union(super::Union),
        #[prost(message, tag = "5")]
        Intersection(super::Intersection),
        #[prost(message, tag = "6")]
        Exclusion(super::Exclusion),
        #[prost(message, tag = "7")]
        WasmModule(super::WasmModule),
    }
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DirectCheck {
    #[prost(string, tag = "1")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub relation: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub subject: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ComputedUserset {
    #[prost(string, tag = "1")]
    pub relation: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub relationship: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RelatedObjectUserset {
    #[prost(string, tag = "1")]
    pub relationship: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub computed: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Union {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Intersection {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Exclusion {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WasmModule {
    #[prost(string, tag = "1")]
    pub module_name: ::prost::alloc::string::String,
}
/// Expand request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExpandRequest {
    /// Resource to expand (e.g., "doc:readme")
    #[prost(string, tag = "1")]
    pub resource: ::prost::alloc::string::String,
    /// Relation to expand (e.g., "viewer")
    #[prost(string, tag = "2")]
    pub relation: ::prost::alloc::string::String,
}
/// Expand response (one user at a time)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpandResponse {
    #[prost(oneof = "expand_response::Payload", tags = "1, 2")]
    pub payload: ::core::option::Option<expand_response::Payload>,
}
/// Nested message and enum types in `ExpandResponse`.
pub mod expand_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        /// A single user in the expanded set
        #[prost(string, tag = "1")]
        User(::prost::alloc::string::String),
        /// Final summary with tree
        #[prost(message, tag = "2")]
        Summary(super::ExpandStreamSummary),
    }
}
/// Summary sent at end of expand stream
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpandStreamSummary {
    /// Complete userset tree
    #[prost(message, optional, tag = "1")]
    pub tree: ::core::option::Option<UsersetTree>,
    /// Total number of users
    #[prost(uint64, tag = "2")]
    pub total_users: u64,
}
/// Userset tree node
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsersetTree {
    /// Node type
    #[prost(message, optional, tag = "1")]
    pub node_type: ::core::option::Option<UsersetNodeType>,
    /// Child nodes
    #[prost(message, repeated, tag = "2")]
    pub children: ::prost::alloc::vec::Vec<UsersetTree>,
}
/// Userset node type
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UsersetNodeType {
    #[prost(oneof = "userset_node_type::Type", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub r#type: ::core::option::Option<userset_node_type::Type>,
}
/// Nested message and enum types in `UsersetNodeType`.
pub mod userset_node_type {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Type {
        #[prost(message, tag = "1")]
        This(super::This),
        #[prost(message, tag = "2")]
        ComputedUserset(super::ComputedUsersetRef),
        #[prost(message, tag = "3")]
        RelatedObjectUserset(super::RelatedObjectUsersetRef),
        #[prost(message, tag = "4")]
        Union(super::UnionNode),
        #[prost(message, tag = "5")]
        Intersection(super::IntersectionNode),
        #[prost(message, tag = "6")]
        Exclusion(super::ExclusionNode),
        #[prost(message, tag = "7")]
        Leaf(super::Leaf),
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct This {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ComputedUsersetRef {
    #[prost(string, tag = "1")]
    pub relation: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RelatedObjectUsersetRef {
    #[prost(string, tag = "1")]
    pub relationship: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub computed: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UnionNode {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct IntersectionNode {}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExclusionNode {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Leaf {
    #[prost(string, repeated, tag = "1")]
    pub users: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Write request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteRequest {
    /// Relationships to write
    #[prost(message, repeated, tag = "1")]
    pub relationships: ::prost::alloc::vec::Vec<Relationship>,
}
/// Write response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WriteResponse {
    /// Revision token
    #[prost(string, tag = "1")]
    pub revision: ::prost::alloc::string::String,
    /// Number of relationships written
    #[prost(uint64, tag = "2")]
    pub relationships_written: u64,
}
/// Filter for deleting relationships
/// All fields are optional and can be combined
/// At least one field must be set to avoid deleting all relationships
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteFilter {
    /// Filter by resource (e.g., "doc:readme")
    #[prost(string, optional, tag = "1")]
    pub resource: ::core::option::Option<::prost::alloc::string::String>,
    /// Filter by relation (e.g., "viewer")
    #[prost(string, optional, tag = "2")]
    pub relation: ::core::option::Option<::prost::alloc::string::String>,
    /// Filter by subject (e.g., "user:alice")
    #[prost(string, optional, tag = "3")]
    pub subject: ::core::option::Option<::prost::alloc::string::String>,
}
/// Delete request
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRequest {
    /// Optional filter for bulk deletion
    /// If provided, all relationships matching the filter will be deleted
    #[prost(message, optional, tag = "1")]
    pub filter: ::core::option::Option<DeleteFilter>,
    /// Optional exact relationships to delete
    /// Can be combined with filter
    #[prost(message, repeated, tag = "2")]
    pub relationships: ::prost::alloc::vec::Vec<Relationship>,
    /// Maximum number of relationships to delete (safety limit)
    /// If not specified, uses default limit (1000)
    /// Set to 0 for unlimited (use with extreme caution!)
    #[prost(uint32, optional, tag = "3")]
    pub limit: ::core::option::Option<u32>,
}
/// Delete response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeleteResponse {
    /// Revision token
    #[prost(string, tag = "1")]
    pub revision: ::prost::alloc::string::String,
    /// Number of relationships deleted
    #[prost(uint64, tag = "2")]
    pub relationships_deleted: u64,
}
/// Health check request
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HealthRequest {}
/// Health check response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HealthResponse {
    /// Status (e.g., "healthy")
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
    /// Service name
    #[prost(string, tag = "2")]
    pub service: ::prost::alloc::string::String,
}
/// List resources request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListResourcesRequest {
    /// Subject (e.g., "user:alice")
    #[prost(string, tag = "1")]
    pub subject: ::prost::alloc::string::String,
    /// Resource type to filter by (e.g., "document")
    #[prost(string, tag = "2")]
    pub resource_type: ::prost::alloc::string::String,
    /// Permission to check (e.g., "can_view")
    #[prost(string, tag = "3")]
    pub permission: ::prost::alloc::string::String,
    /// Optional limit on number of resources to return
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
    /// Optional continuation token from previous request
    #[prost(string, optional, tag = "5")]
    pub cursor: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional resource ID pattern filter (supports wildcards: * matches any characters, ? matches single character)
    /// Examples: "doc:readme\*", "user:alice\_?", "folder:\*/subfolder"
    #[prost(string, optional, tag = "6")]
    pub resource_id_pattern: ::core::option::Option<::prost::alloc::string::String>,
}
/// List resources response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListResourcesResponse {
    /// Resource ID (e.g., "document:readme")
    #[prost(string, tag = "1")]
    pub resource: ::prost::alloc::string::String,
    /// Continuation token for pagination (only set in final message)
    #[prost(string, optional, tag = "2")]
    pub cursor: ::core::option::Option<::prost::alloc::string::String>,
    /// Total count estimate (only set in final message, may be approximate)
    #[prost(uint64, optional, tag = "3")]
    pub total_count: ::core::option::Option<u64>,
}
/// List relationships request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListRelationshipsRequest {
    /// Optional filter by resource (e.g., "doc:readme")
    #[prost(string, optional, tag = "1")]
    pub resource: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional filter by relation (e.g., "viewer")
    #[prost(string, optional, tag = "2")]
    pub relation: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional filter by subject (e.g., "user:alice")
    #[prost(string, optional, tag = "3")]
    pub subject: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional limit on number of relationships to return (default: 100, max: 1000)
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
    /// Optional continuation token from previous request
    #[prost(string, optional, tag = "5")]
    pub cursor: ::core::option::Option<::prost::alloc::string::String>,
}
/// Relationship represents an authorization relationship with API-friendly naming
/// (resource, relation, subject) instead of the storage-level (object, relation, user)
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Relationship {
    /// Resource identifier (e.g., "doc:readme")
    #[prost(string, tag = "1")]
    pub resource: ::prost::alloc::string::String,
    /// Relation type (e.g., "viewer", "editor")
    #[prost(string, tag = "2")]
    pub relation: ::prost::alloc::string::String,
    /// Subject identifier (e.g., "user:alice", "group:engineers")
    #[prost(string, tag = "3")]
    pub subject: ::prost::alloc::string::String,
}
/// List relationships response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListRelationshipsResponse {
    /// A single relationship
    #[prost(message, optional, tag = "1")]
    pub relationship: ::core::option::Option<Relationship>,
    /// Continuation token for pagination (only set in final message)
    #[prost(string, optional, tag = "2")]
    pub cursor: ::core::option::Option<::prost::alloc::string::String>,
    /// Total count of relationships returned (only set in final message)
    #[prost(uint64, optional, tag = "3")]
    pub total_count: ::core::option::Option<u64>,
}
/// List subjects request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListSubjectsRequest {
    /// Resource (e.g., "document:readme")
    #[prost(string, tag = "1")]
    pub resource: ::prost::alloc::string::String,
    /// Relation to check (e.g., "viewer")
    #[prost(string, tag = "2")]
    pub relation: ::prost::alloc::string::String,
    /// Optional filter by subject type (e.g., "user", "group")
    #[prost(string, optional, tag = "3")]
    pub subject_type: ::core::option::Option<::prost::alloc::string::String>,
    /// Optional limit on number of subjects to return
    #[prost(uint32, optional, tag = "4")]
    pub limit: ::core::option::Option<u32>,
    /// Optional continuation token from previous request
    #[prost(string, optional, tag = "5")]
    pub cursor: ::core::option::Option<::prost::alloc::string::String>,
}
/// List subjects response
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ListSubjectsResponse {
    /// Subject ID (e.g., "user:alice", "group:admins")
    #[prost(string, tag = "1")]
    pub subject: ::prost::alloc::string::String,
    /// Continuation token for pagination (only set in final message)
    #[prost(string, optional, tag = "2")]
    pub cursor: ::core::option::Option<::prost::alloc::string::String>,
    /// Total count estimate (only set in final message, may be approximate)
    #[prost(uint64, optional, tag = "3")]
    pub total_count: ::core::option::Option<u64>,
}
/// Watch request
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WatchRequest {
    /// Optional filter by resource type (e.g., "document", "folder")
    /// If not specified, watches all relationship changes
    #[prost(string, repeated, tag = "1")]
    pub resource_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Optional start revision/cursor to resume from
    /// If not specified, starts from current point in time
    /// If specified as "0" or empty, starts from beginning of available change log
    #[prost(string, optional, tag = "2")]
    pub cursor: ::core::option::Option<::prost::alloc::string::String>,
}
/// Watch response - streams relationship changes
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WatchResponse {
    /// Type of change operation
    #[prost(enumeration = "ChangeOperation", tag = "1")]
    pub operation: i32,
    /// The relationship that changed
    #[prost(message, optional, tag = "2")]
    pub relationship: ::core::option::Option<Relationship>,
    /// Revision at which this change occurred
    #[prost(string, tag = "3")]
    pub revision: ::prost::alloc::string::String,
    /// Timestamp when the change occurred (ISO 8601 format)
    #[prost(string, tag = "4")]
    pub timestamp: ::prost::alloc::string::String,
}
/// Simulate request - test authorization with ephemeral relationships
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateRequest {
    /// Ephemeral relationships to use for this check (temporary context)
    /// These relationships exist ONLY for this simulation and are not persisted
    #[prost(message, repeated, tag = "1")]
    pub context_relationships: ::prost::alloc::vec::Vec<Relationship>,
    /// The check to evaluate against the ephemeral context
    #[prost(message, optional, tag = "2")]
    pub check: ::core::option::Option<SimulateCheck>,
}
/// The authorization check to perform in the simulation
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SimulateCheck {
    /// Subject (e.g., "user:alice")
    #[prost(string, tag = "1")]
    pub subject: ::prost::alloc::string::String,
    /// Resource (e.g., "doc:readme")
    #[prost(string, tag = "2")]
    pub resource: ::prost::alloc::string::String,
    /// Permission to evaluate (e.g., "viewer")
    #[prost(string, tag = "3")]
    pub permission: ::prost::alloc::string::String,
    /// Optional context data for WASM modules
    #[prost(string, optional, tag = "4")]
    pub context: ::core::option::Option<::prost::alloc::string::String>,
}
/// Simulate response
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SimulateResponse {
    /// Authorization decision based on ephemeral context
    #[prost(enumeration = "Decision", tag = "1")]
    pub decision: i32,
    /// Number of context relationships used in simulation
    #[prost(uint64, tag = "2")]
    pub context_relationships_count: u64,
}
/// Decision enum
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Decision {
    Unspecified = 0,
    Allow = 1,
    Deny = 2,
}
impl Decision {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DECISION_UNSPECIFIED",
            Self::Allow => "DECISION_ALLOW",
            Self::Deny => "DECISION_DENY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DECISION_UNSPECIFIED" => Some(Self::Unspecified),
            "DECISION_ALLOW" => Some(Self::Allow),
            "DECISION_DENY" => Some(Self::Deny),
            _ => None,
        }
    }
}
/// Type of relationship change
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChangeOperation {
    Unspecified = 0,
    /// Relationship was created
    Create = 1,
    /// Relationship was deleted
    Delete = 2,
}
impl ChangeOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CHANGE_OPERATION_UNSPECIFIED",
            Self::Create => "CHANGE_OPERATION_CREATE",
            Self::Delete => "CHANGE_OPERATION_DELETE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHANGE_OPERATION_UNSPECIFIED" => Some(Self::Unspecified),
            "CHANGE_OPERATION_CREATE" => Some(Self::Create),
            "CHANGE_OPERATION_DELETE" => Some(Self::Delete),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod inferadb_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    /// The main Infera authorization service
    #[derive(Debug, Clone)]
    pub struct InferadbServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl InferadbServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> InferadbServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InferadbServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::Body>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            InferadbServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Evaluate if a subject has permission on a resource
        /// Supports optional detailed tracing for debugging
        pub async fn evaluate(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::EvaluateRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::EvaluateResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/inferadb.v1.InferadbService/Evaluate");
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("inferadb.v1.InferadbService", "Evaluate"));
            self.inner.streaming(req, path, codec).await
        }
        /// Expand a relation into its userset tree
        pub async fn expand(
            &mut self,
            request: impl tonic::IntoRequest<super::ExpandRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ExpandResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/inferadb.v1.InferadbService/Expand");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("inferadb.v1.InferadbService", "Expand"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Write relationships to the store
        pub async fn write_relationships(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::WriteRequest>,
        ) -> std::result::Result<tonic::Response<super::WriteResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/inferadb.v1.InferadbService/WriteRelationships",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "inferadb.v1.InferadbService",
                "WriteRelationships",
            ));
            self.inner.client_streaming(req, path, codec).await
        }
        /// Delete relationships from the store
        pub async fn delete_relationships(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::DeleteRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/inferadb.v1.InferadbService/DeleteRelationships",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "inferadb.v1.InferadbService",
                "DeleteRelationships",
            ));
            self.inner.client_streaming(req, path, codec).await
        }
        /// Health check
        pub async fn health(
            &mut self,
            request: impl tonic::IntoRequest<super::HealthRequest>,
        ) -> std::result::Result<tonic::Response<super::HealthResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/inferadb.v1.InferadbService/Health");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("inferadb.v1.InferadbService", "Health"));
            self.inner.unary(req, path, codec).await
        }
        /// List resources accessible by a subject
        pub async fn list_resources(
            &mut self,
            request: impl tonic::IntoRequest<super::ListResourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ListResourcesResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/inferadb.v1.InferadbService/ListResources");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "inferadb.v1.InferadbService",
                "ListResources",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        /// List relationships (relationships) with optional filtering
        pub async fn list_relationships(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRelationshipsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ListRelationshipsResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/inferadb.v1.InferadbService/ListRelationships",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "inferadb.v1.InferadbService",
                "ListRelationships",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        /// List subjects that have a specific relation to a resource
        pub async fn list_subjects(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSubjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ListSubjectsResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/inferadb.v1.InferadbService/ListSubjects");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "inferadb.v1.InferadbService",
                "ListSubjects",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Watch for real-time relationship changes
        pub async fn watch(
            &mut self,
            request: impl tonic::IntoRequest<super::WatchRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::WatchResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/inferadb.v1.InferadbService/Watch");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("inferadb.v1.InferadbService", "Watch"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Simulate authorization with ephemeral relationships (what-if testing)
        pub async fn simulate(
            &mut self,
            request: impl tonic::IntoRequest<super::SimulateRequest>,
        ) -> std::result::Result<tonic::Response<super::SimulateResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic_prost::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/inferadb.v1.InferadbService/Simulate");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("inferadb.v1.InferadbService", "Simulate"));
            self.inner.unary(req, path, codec).await
        }
    }
}
